---
title: "10_Regression_analysis"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Useful tutorial. There are two others in the repository folder now also
https://sejdemyr.github.io/r-tutorials/statistics/tutorial8.html


#### 1. Load packages, set working directory, and prevent scientific notation
```{r get_packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(rgdal)
library(sf)
library(MatchIt) ## Package with Propensity Score Matching
library(optmatch)
options(scipen = 9999) ## Avoid scientific notation
# setwd("~/Desktop/Organics_Final/Working/organics_repo/") # Set working directory to make relative filepath names work


```

Simple linear regression equation

$Annual~kg/H = croptype + CDFA~organic + field~size + soil~quality$

#### 2. Prepare regression dataframe

# Get data and make a dataframe to be used in regression analysis. 
This is not important, it just gets rid of '-ORGANIC' from the commodity column and groups lettuce together, rather than having 'LETTUCE LEAF' and 'LETTUCE' as separate crop types. 
```{r get_data, echo=TRUE, message=FALSE, warning=FALSE}

data = read_csv("../R_output/CSV/compiled_organics1317.csv")


#### Code currently just looks at 2017...not necessarily the best thing!!###

ag_summary = data %>% 
  filter(year == 2017) %>% 
     group_by(comm_edit) %>% 
     summarise(total_fields = n(),
               organic_fields = sum(cdfa_org),
               conv_fields = n()-sum(cdfa_org)) %>% 
  filter(organic_fields > 9 & conv_fields > 9) %>% 
  arrange(-organic_fields)

common_crops = as.factor(as.character(ag_summary$comm_edit))
agro_classes = as.factor(as.character(data$agroclass[data$cdfa_org==1]))

comm_regression_df = data %>% 
  filter(year == 2017) %>% 
  filter(soil_quality > 0 & comm_edit%in%common_crops) %>% 
  dplyr::select(permitsite,
         permittee,
         "croptype" = comm_edit,
         cdfa_org,
         soil_quality,
         KgPstAI,
         KgPerHE,
         hectares)

agroclass_regression_df = data %>% 
  filter(year == 2017) %>% 
  filter(soil_quality >0 & agroclass%in%agro_classes) %>% 
  dplyr::select(agroclass,
         comm_edit,
         cdfa_org,
         soil_quality,
         KgPstAI,
         KgPerHE,
         hectares)
```

# Data Exploration
```{r data_explore}

ggplot(comm_regression_df, aes(x = cdfa_org, y = soil_quality))+
  geom_point()+
  geom_line()

ggplot(agroclass_regression_df, aes(x = cdfa_org, y = hectares))+
  geom_point()+
  geom_line()

```


# Simple Linear Regression -- Just seeing how R is recognizing/processing covariates
```{r SLR}

## On individual crop types
simple_comm_reg = lm(KgPerHE ~ croptype + cdfa_org + soil_quality + hectares, data = comm_regression_df) # Mainly to see how data is being read in regression
summary(simple_comm_reg) # Look at regression results

## On agro class groups
simple_agroclass_reg = lm(KgPerHE ~ agroclass + cdfa_org + soil_quality + hectares, data = agroclass_regression_df) # Mainly to see how data is being read in regression
summary(simple_agroclass_reg) # Look at regression results


# These are/were just to try to understand more about fieldsize and soil quality. 
# field_soil_lm = lm(soil_quality~hectares, data=comm_regression_df)
# summary(field_soil_lm)
# 
# field_soil_lm = lm(soil_quality~hectares, data=comm_regression_df)
# summary(field_soil_lm)
# ## On broad agro classes

```


# Propensity score estimation for dataset with Crop reference variable
```{r estimate_scores}
### Currently with agro class ###

propensity_logit = glm(cdfa_org ~ agroclass + soil_quality + hectares, 
                       family = binomial, 
                       data = agroclass_regression_df)

# summary(propensity_logit)

# Predict propensity scores and place in a new column
pscore_df = data.frame(pr_score = predict(propensity_logit,type = "response"),
                       cdfa_org = agroclass_regression_df$cdfa_org)

```


# Look at propensity score distribution
```{r pscore_distribution}
ggplot(pscore_df,aes(x = pr_score))+
  geom_histogram(color="white",bins=15)+
  facet_wrap(~cdfa_org)+
  theme_bw()
```

# Propensity score matching
```{r find_matches}
# The following paragraph is the MatchIt package author's explanation of the matchit() function that I use below

# matchit is the main command of the package MatchIt, which enables parametric models for causal inference to work better by selecting well-matched subsets of the original treated and control groups. MatchIt implements the suggestions of Ho, Imai, King, and Stuart (2004) for improving parametric statistical models by preprocessing data with nonparametric matching methods. MatchIt implements a wide range of sophisticated matching methods, making it possible to greatly reduce the dependence of causal inferences on hard-to-justify, but commonly made, statistical modeling assumptions. The software also easily fits into existing research practices since, after preprocessing with MatchIt, researchers can use whatever parametric model they would have used without MatchIt, but produce inferences with substantially more robustness and less sensitivity to modeling assumptions. 

# this can take a little while depending on the arguments included
match = matchit(cdfa_org ~ agroclass + soil_quality + hectares, 
                method = "nearest", 
                replace = F,
                ratio = 2,
                data = agroclass_regression_df)

# Matchit notes
# https://cran.r-project.org/web/packages/MatchIt/MatchIt.pdf
# replace = T to sample with replacement
# ratio = 1 Match each Tx obs to one control obs

# summary(match)
# plot(match)

# match.data outputs matched data sets from matchit()
matches <- match.data(match)
dim(matches)
```


Look at difference in means between matches to see if they're closer than in the original data set. 
- Differences should not be significant AKA fail to reject the null
```{r check_matches}
cov <- c('soil_quality','hectares') # Covariates to check matches with

matches %>%
  group_by(cdfa_org) %>% # Seperate the two CDFA groups (1 = ORGANIC, 0 = CONVENTIONAL)
  dplyr::select(one_of(cov)) %>%
  summarise_all(funs(mean))  # Find the means of each covariate group within the org or conv groups

t.test(matches$soil_quality ~ matches$cdfa_org)
t.test(matches$hectares ~ matches$cdfa_org)

# Checking another way
ggplot(matches,aes(x = distance,y = soil_quality,color=cdfa_org))+
  geom_point()+
  geom_smooth(method = "loess")+
  theme_bw()

ggplot(matches,aes(x = distance,y = hectares,color=cdfa_org))+
  geom_point()+
  geom_smooth(method = "loess")+
  theme_bw()

ggplot(matches,aes(x = distance,y = agroclass,color=cdfa_org))+
  geom_point()+
  theme_bw()

```


# THE TWO PROPENSITY SCORE REGRESSION EQUATIONS
************
## Regression with **propensity scores as covariate**
```{r reg_with_pscores}

comm_regression_df$pscores = predict.glm(propensity_logit,type="response")
comm_regression_filter = comm_regression_df %>% 
  filter(pscores > 0.3 & pscores < 0.7)

pscore_reg = lm(KgPerHE ~ croptype + cdfa_org + hectares + soil_quality + pscores, data = comm_regression_filter)
summary(pscore_reg)

plot(pscore_reg)
```


************
## Regression on **matches data.frame**, *propensity score not used as covariate*
```{r match_regression}

matches_filter = matches %>% 
  filter(distance > .1 & distance <.9)

matches_reg = lm(KgPerHE ~ croptype + cdfa_org + hectares + soil_quality , data = matches_filter)
summary(matches_reg)

plot(matches_reg)

```




