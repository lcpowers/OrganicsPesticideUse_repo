---
title: "Join PesticideUseData to Finazlied Organic Parcel Shapefile for all years"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**The purpose of this Rmarkdown file is to join pesticide use data to the Kern County Agriculture-CDFA shapeile created in the previous Rmarkdown document, to then compare pesticide use  and other environmental characteristics across conventional and organic fields.**  


**Notes:**

- In code chunk 5, this document also determines the number of crops being grown on each field. This helps us prevent bias that may arise from pesticide use data associated with fields that have multiple crops [S_STATUS == "M"].

**Output:**
- Shapefile that includes information from Kern Ag, CDFA, Storie Index (soil), and Pesticide use data in the attribute table
      * "../R_output/spatial/KernAg_CDFA_pest/",i,"/B50"
       where 'i' is the year being evaluated

---


#### 1. Get Packages and Data
```{r get_packages_and_data}
library(haven)
library(tidyverse)
library(rgdal)
library(stringi)
library(sf)
library(fuzzyjoin)

# setwd("~/Projects/Organics/Working/organics_repo/Rmarkdown/")

# Avoid scientific notation in dataframes
options(scipen = 999) 

# Read in Pesticide Data 
pest_data_raw = read_dta("../R_input/dta/KernOrgCollapse1319_062920.dta") %>% 
  as.data.frame() 

## Remember to deal with the commodity different but everything else identical issue

# Specify years of interest
years = 2013:2019

# Specify buffer width being analyzed -- Buffer widths were originally implemented in the Kern Agriculture CDFA Parcel spatial join. 
buf_width = c(50)
```

################# Fuzzy match ideas,methods #####################
Exact match on permit, fuzzy match on site
- Permit is in the Ag attribute table already. To get site we can just trim off the Permit # from the permit site column OR rerun the KernAg to soil rmd with an update to keep the "site" column that we currently get rid of...

#### 2. Create pesticide use dataframes for each year
```{r pest_dataframes, message=FALSE}

#### For loop to create dataframes of pesticide use for each year from 2013:2019
for(i in years){ 
  
  # Filter pesticide data year i
  tmp <- filter(pest_data_raw,year==i)
  
  # Give it a name for that specific year
  assign(paste0("pest_data_",i),tmp)
  
  }

nrow(pest_data_2013)
n_distinct(pest_data_2013$permitsite,pest_data_2013$commodity)
# PS_dups_13 = as.data.frame(table(pest_data_2013$permitsite,pest_data_2013$commodity)) %>% filter(Freq>1) %>% mutate(year = 13)

nrow(pest_data_2014)
n_distinct(pest_data_2014$permitsite, pest_data_2014$commodity)
# PS_dups_14 = as.data.frame(table(pest_data_2014$permitsite, pest_data_2014$commodity)) %>% filter(Freq>1) %>% mutate(year = 14)

nrow(pest_data_2015)
n_distinct(pest_data_2015$permitsite,pest_data_2015$commodity)
# PS_dups_15 = as.data.frame(table(pest_data_2015$permitsite)) %>% filter(Freq>1) %>% mutate(year = 15)

nrow(pest_data_2016)
n_distinct(pest_data_2016$permitsite,pest_data_2016$commodity)
# PS_dups_16 = as.data.frame(table(pest_data_2016$permitsite)) %>% filter(Freq>1) %>% mutate(year = 16)

nrow(pest_data_2017)
n_distinct(pest_data_2017$permitsite,pest_data_2017$commodity)
# PS_dups_17 = as.data.frame(table(pest_data_2017$permitsite)) %>% filter(Freq>1) %>% mutate(year = 17)

nrow(pest_data_2018)
n_distinct(pest_data_2018$permitsite,pest_data_2018$commodity)
# PS_dups_18 = as.data.frame(table(pest_data_2018$permitsite)) %>% filter(Freq>1) %>% mutate(year = 18)

nrow(pest_data_2019)
n_distinct(pest_data_2019$permitsite,pest_data_2019$commodity)
# PS_dups_19 = as.data.frame(table(pest_data_2019$permitsite)) %>% filter(Freq>1) %>% mutate(year = 19)

# PS_dups = rbind(PS_dups_13,PS_dups_14,PS_dups_15,PS_dups_16,PS_dups_17)
# colnames(PS_dups) = c("permitsite","n_dups","year")
```


#### 3. Read in KernAg_CDFA shapefiles for each year and give unique name
```{r get_kernAg}

# Read in KernAg_CDFA (joined) shapefile with appropriate buffer and convert to spatial dataframe
# Also fixes the commodity column in '18 and '19 where the word "ORGANIC" is truncated in some cells, which effects the permitsite/comm join in the following code chunk

for(i in years){ # For each year...
  for(j in buf_width){ # And each buffer width...
  
  # Read in the joined KernAg_CDFA data...
  tmp <- read_sf(paste0("../R_output/spatial/CDFA_KernAg_join/",i,"/buffer",j,"/all_organics_",i,".shp")) 

  
  # Assign a name
  assign(paste0("organics_",i,"_B",j),tmp)
  
  remove(tmp)
    }
}

# organics_2018_B50$comm = as.character(organics_2018_B50$comm)
# organics_2018_B50 <- separate(organics_2018_B50,comm,into = c("comm","suf"),sep = "-")
# organics_2018_B50$suf = ifelse(str_detect(string = organics_2018_B50$suf, pattern = "OR"), "ORGANIC", organics_2018_B50$suf)
# organics_2018_B50$comm = ifelse(!is.na(organics_2018_B50$suf),paste0(organics_2018_B50$comm,"-",organics_2018_B50$suf),organics_2018_B50$comm)
# organics_2018_B50 = dplyr::select(organics_2018_B50, -suf)
# 
# organics_2019_B50$comm = as.character(organics_2019_B50$comm)
# organics_2019_B50 <- separate(organics_2019_B50,comm,into = c("comm","suf"),sep = "-")
# organics_2019_B50$suf = ifelse(str_detect(string = organics_2019_B50$suf, pattern = "OR"), "ORGANIC", organics_2019_B50$suf)
# organics_2019_B50$comm = ifelse(!is.na(organics_2019_B50$suf),paste0(organics_2019_B50$comm,"-",organics_2019_B50$suf),organics_2019_B50$comm)
# organics_2019_B50 = dplyr::select(organics_2019_B50, -suf)

```


#### 4. Join pesticide data to Kern Agriculture/CDFA data by the 'permitsite' column. The 'permitsite' column is the unique identifier for each field, and is a concatenated version of the permit number and site ID. 
```{r}
for(i in years){
  
  # Find the data.frame that was previously read in and corresponds 
  # to year.i and buffer_width.j
  tmp_ag = eval(as.name(paste0("organics_",i,"_B",j)))  %>% 
    as.data.frame() 
  
  colnames(tmp_ag)[2] <- "permitsite"
  colnames(tmp_ag)[5] <- "commodity"
  
  # Check to make sure all permits are 7 characters long -- check all years in RMD 6 and true: all permits = 7 characters long
  # nchars = as.data.frame(table(nchar(tmp_ag$permit)))
  
  # Create a site column
  tmp_ag$site = substr(tmp_ag$permitsite,8,nchar(tmp_ag$permitsite))
  
  # Get temp copy of the pesticide use data.frame that corresponds to pest_data_year.i
  tmp_pst = eval(as.name(paste0("pest_data_",i)))
  
  # Left join the pesticide use data.frame to the Agriculture shapefile on 'permitsite' and 'commodity' -- use this to data.frame to filter out fuzzy joins
  full_joined_ag_pst = full_join(tmp_ag,tmp_pst, by = c("permitsite", "commodity"), suffix = c(".ag", ".pur"))
  anti_joined_ag = anti_join(tmp_ag,tmp_pst,by = c("permitsite", "commodity"), suffix = c(".ag", ".pur"))
  anti_joined_pst = anti_join(tmp_pst,tmp_ag,by = c("permitsite", "commodity"), suffix = c(".pur", ".ag"))
  
  print(table(is.na(left_joined_ag_pst$permit.pur)))
  
  # # Inner join to find all the kern ag rows and PUR rows that don't join
  anti_joined_ag = anti_join(tmp_ag,tmp_pst, by = c("permitsite"), suffix = c(".ag", ".pur"))
  
  # anti_joined_pst = anti_join(tmp_pst,tmp_ag, by = c("permitsite"), suffix = c(".ag", ".pur"))
  # 
  
  # Assign a unique name based on the year
  assign(paste0("organics_pest_",i), left_joined_ag_pst)
  
}

```

#### 5. Determine the number of crops being grown on multi-crop fields (s_status == "M") and add information to the KernAg_CDFA_pesticideUse dataframe shapefile.
```{r deal_with_Mfields}

for(i in years){
  
  tmp_orgs_df = eval(as.name(paste0("organics_pest_",i)))
      
  # Turn the kernAg_CDFA_pest shapefile into a simple features (spatial) data.frame
      M_status_df = tmp_orgs_df %>% 
        # Turn into basic data.frame to remove spatial references
        as.data.frame() %>% 
        # Select columns relevant to dealing with M fields
        dplyr::select(permitsite,s_stats)
  
      # Create a new column of permitsites with the last character trimmed from each 
      # 'permitsite' string that correspond to a field with an "M" in the "S_STATUS" column.

      # For rows with "M" in column "S_STATUS"
      M_status_df$permitsite_trim1 = ifelse(M_status_df$s_stats == "M", 
          
        # Trim the last character off the 'permitsite' string
        strtrim(M_status_df$permitsite,width=nchar(M_status_df$permitsite)-1),
    
        # Leave other rows alone
        M_status_df$permitsite)
    
      
      # Create another new column from the original "permitsite" field with only the last character 
      # from the string. This is used to double check the seperation of characters in the step above. If concatenated,
      # '_trim1' + '_trim2' should be identical to the original 'permitsite' string.  
      
      # If the value in 'S_STATUS' == M
      M_status_df$permitsite_trim2 = ifelse(M_status_df$s_stats == "M",
                                     
           # Grab the last character in the 'permitsite' string
           substr(x = M_status_df$permitsite,
           start = nchar(M_status_df$permitsite),
           stop = nchar(M_status_df$permitsite)), 
        
           # Otherwise make equal to NA
           NA)

      
      # Create a new dataframe that has each unique 'permitsite' string in the first column
      # and the number of times it is repeated in the second column. Multi-crop fields (S_STATUS == M) 
      # are consistently distinguised from one another by a unique character at the end (right side) 
      # of an otherwise identical 'permitsite' string. With the last character trimmed off of those strings, 
      # we can determine the number of crops in the multi-crop fields based on the number of duplicate
      # permitsites in the 'permitsite_trim1' column.
      prmtst_duplicates = as.data.frame(table(M_status_df$permitsite_trim1))
      
      
      # Rename columns from generic names given by table() function
      colnames(prmtst_duplicates) = c('permitsite','n')
      
      # Merge multicrop_df data.frame (with permitsite_trim columns) and prmtst_dups data.frame. This merge 
      # allows us to see how many crops are associated with each permitsite i.e. how many 
      # crops are in each individual field. 
      M_status_df_final = merge(M_status_df, 
                                 prmtst_duplicates, 
                                 by.x="permitsite_trim1", 
                                 by.y="permitsite", 
                                 type = "right") %>% 
        dplyr::select(permitsite,n)
      
      # Rename columns for merge and later use
      colnames(M_status_df_final) = c("permitsite","N_crops_prmtst")
      
      # Merge the final multicrop_df dataframe into the tmp_orgs_df_final simple features data.frame
      orgs_df_final = merge(tmp_orgs_df, M_status_df_final, by = 'permitsite')
      
      # Remove extra dataframes that could accidentally carry into other years
      remove(M_status_df_final,prmtst_duplicates,M_status_df,tmp_orgs_df)
      
      # Convert the acres column to numeric
      orgs_df_final$acres = as.numeric(as.character(orgs_df_final$acres))
      
      # create a 'hectares' column using the 'acres' column
      orgs_df_final$hectares = orgs_df_final$acres*0.405/orgs_df_final$N_crops_prmtst
      
      # Create a kilograms of active ingredients per hectare column
      # orgs_df_final$kgAIperhec = orgs_df_final$KgPestAI/orgs_df_final$hectares
      # orgs_df_final$kgPrdPerHe = orgs_df_final$KgPestPrd/orgs_df_final$hectares
      
      # Remove the "permitno" and "location" columns
      # orgs_df_final = orgs_df_final %>% 
      #   select(-c("permitno","location"))
      
      # Save in global environment
      assign(paste0("organics_df_final_",i), orgs_df_final)
      
        # Write the shapefile in to the output directory
        writeOGR(as(st_as_sf(orgs_df_final),"Spatial"),
                 paste0("../R_output/spatial/final_organics_data/",i),
                 paste0("all_organics_pest_",i),
                 driver = "ESRI Shapefile",
                 overwrite_layer = TRUE)
        
}

```




