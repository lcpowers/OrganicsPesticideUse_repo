---
title: "Join PesticideUseData to Finazlied Organic Parcel Shapefile for all years"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**The purpose of this Rmarkdown file is to join pesticide use data to the Kern County Agriculture-CDFA shapeile created in the previous Rmarkdown document, to then compare pesticide use  and other environmental characteristics across conventional and organic fields.**  


**Notes:**

- In code chunk 5, this document also determines the number of crops being grown on each field. This helps us prevent bias that may arise from pesticide use data associated with fields that have multiple crops [S_STATUS == "M"].

**Output:**
- Shapefile that includes information from Kern Ag, CDFA, Storie Index (soil), and Pesticide use data in the attribute table
      * "../R_output/spatial/KernAg_CDFA_pest/",i,"/B50"
       where 'i' is the year being evaluated

---


#### 1. Get Packages and Data
```{r get_packages_and_data}
library(haven)
library(tidyverse)
library(rgdal)
library(stringi)
library(sf)
# setwd("~/Projects/Organics/Working/organics_repo/Rmarkdown/")

# Avoid scientific notation in dataframes
options(scipen = 999) 

# Read in Pesticide Data 
pest_data_raw = read_stata("../R_input/dta/KernOrgCollapse1319.dta") %>% 
  dplyr::select("permit" = permitno,
         "site" = location,year)
pest_data_raw$permitsite = paste0(as.character(pest_data_raw$permit),as.character(pest_data_raw$site))

# Specify years of interest
years = 2013:2019

# Specify buffer width being analyzed -- Buffer widths were originally implemented in the Kern Agriculture CDFA Parcel spatial join. 
buf_width = c(50)
```

################# Fuzzy match ideas,methods #####################
Exact match on permit, fuzzy match on site
- Permit is in the Ag attribute table already. To get site we can just trim off the Permit # from the permit site column OR rerun the KernAg to soil rmd with an update to keep the "site" column that we currently get rid of...

#### 2. Create pesticide use dataframes for each year
```{r pest_dataframes, message=FALSE}

#### For loop to create dataframes of pesticide use for each year from 2013:2019
for(i in years){ 
  
  # Filter pesticide data year i
  tmp <- filter(pest_data_raw,year==i)
  
  # Give it a name for that specific year
  assign(paste0("pest_data_",i),tmp)
  
  }

nrow(pest_data_2013)
n_distinct(pest_data_2013$permitsite)
# PS_dups_13 = as.data.frame(table(pest_data_2013$permitsite)) %>% filter(Freq>1) %>% mutate(year = 13)

nrow(pest_data_2014)
n_distinct(pest_data_2014$permitsite)
# PS_dups_14 = as.data.frame(table(pest_data_2014$permitsite)) %>% filter(Freq>1) %>% mutate(year = 14)

nrow(pest_data_2015)
n_distinct(pest_data_2015$permitsite)
# PS_dups_15 = as.data.frame(table(pest_data_2015$permitsite)) %>% filter(Freq>1) %>% mutate(year = 15)

nrow(pest_data_2016)
n_distinct(pest_data_2016$permitsite)
# PS_dups_16 = as.data.frame(table(pest_data_2016$permitsite)) %>% filter(Freq>1) %>% mutate(year = 16)

nrow(pest_data_2017)
n_distinct(pest_data_2017$permitsite)
# PS_dups_17 = as.data.frame(table(pest_data_2017$permitsite)) %>% filter(Freq>1) %>% mutate(year = 17)

nrow(pest_data_2018)
n_distinct(pest_data_2018$permitsite)
# PS_dups_18 = as.data.frame(table(pest_data_2018$permitsite)) %>% filter(Freq>1) %>% mutate(year = 18)

nrow(pest_data_2019)
n_distinct(pest_data_2019$permitsite)
# PS_dups_19 = as.data.frame(table(pest_data_2019$permitsite)) %>% filter(Freq>1) %>% mutate(year = 19)


# PS_dups = rbind(PS_dups_13,PS_dups_14,PS_dups_15,PS_dups_16,PS_dups_17)
# colnames(PS_dups) = c("permitsite","n_dups","year")
```


#### 3. Read in KernAg_CDFA shapefiles for each year and give unique name
```{r get_kernAg}

# Read in KernAg_CDFA (joined) shapefile with appropriate buffer and convert to spatial dataframe
for(i in years){ # For each year...
  for(j in buf_width){ # And each buffer width...
  
  # Read in the joined KernAg_CDFA data...
  tmp <- read_sf(paste0("../R_output/spatial/CDFA_KernAg_join/",i,"/buffer",j,"/all_organics_",i,".shp")) 

  # Assign a name
  assign(paste0("organics_",i,"_B",j),tmp)
  
  remove(tmp)
    }
}

```


#### 4. Join pesticide data to Kern Agriculture/CDFA data by the 'permitsite' column. The 'permitsite' column is the unique identifier for each field, and is a concatenated version of the permit number and site ID. 
```{r join_KernAgCDFAData_to_pestData}

for(i in years){
  
  # Find the data.frame that was previously read in and corresponds 
  # to year.i and buffer_width.j
  tmp_ag = eval(as.name(paste0("organics_",i,"_B",j)))
  
  # Find the pesticide use data.frame that corresponds to pest_data_year.i
  tmp_pst = eval(as.name(paste0("pest_data_",i)))
  
  # Join the pesticide use data.frame to the 
  # Agriculture shapefile on 'permitsite' and keep only the rows that had matches
  join_pst = left_join(tmp_ag,tmp_pst, by = c("permtst" = "permitsite"), suffix = c(".ag", ".pur"))
  
  # To which ones don't join -- This is what we could use for the fuzzy match to then just rbind the results together?
  anti_join = anti_join(tmp_pst,tmp_ag, by = c("permitsite" = "permtst"), suffix = c(".ag", ".pur"))
  
  join_pst$year = i
  
  #Replace NA in outcome variables with 0
  col_join_pst<-colnames(join_pst)[21:22] #Changed to only 21 & 22
  join_pst<-join_pst %>% mutate_at(vars(col_join_pst), ~replace_na(., 0))
  
  # Assign a unique name based on the year
  assign(paste0("organics_pest_",i), join_pst)
  assign(paste0("pest_nomatch_",i), anti_join)
  
  # Remove the temporary data.frame to avoid errors
  remove(tmp_pst, tmp_ag, join_pst, anti_join)
  
}
```



### IGNORE FOR NOW All the stuff in this chunck was just digging into all the pesticide use data that didn't join with kern ag data on permitsite 
```{r}
# 
# # Read in original Pesticide use reports from the Kern Website
# original_PUR = read.csv("../R_input/CSV/KC17PURS.csv")
# 
# # Create permitsite column
# original_PUR$permitsite = as.character(paste0(original_PUR$Permit..,original_PUR$Site.ID))
# 
# # Create new dataframe with all unique permitsites
# uniquePURs = data.frame("permitsite"=unique(original_PUR$permitsite))
# 
# ## Compare to PUR data from Ashley
# # ASHLEY PEST DATA versus KERN AG PEST DATA
# matches_PURs = inner_join(pest_data_2017,uniquePURs,by="permitsite")
# 
# # KERN AG PEST DATA versus ASHLEY PEST DATA
# kern_PUR_mismatch = anti_join(uniquePURs,pest_data_2017,by="permitsite")
# 
# # ASHLEY PEST DATA versus KERN AG PEST DATA 
# ashley_PUR_mismatch = anti_join(pest_data_2017,uniquePURs,by="permitsite")
# 
# mismatches = data.frame("FromKernPUR" = sort(kern_PUR_mismatch$permitsite),
#                            "fromKernOrgCollapseCSV" = sort(ashley_PUR_mismatch$permitsite))
# 
# write.csv(mismatches,"../R_output/CSV/PUR_permitsite_mismatches.csv")
# 
# # Try joining Kern PUR to Kern AG to see how many matches
# # Join the pesticide use data.frame to the 
#   # Agriculture shapefile on 'permitsite' and keep only the rows that had matches
# 
# KernPUR_ag_join = left_join(organics_2017_B50,uniquePURs, by = c("permtst" = "permitsite"))
# KernPUR_ag_join_PURmismatch = anti_join(uniquePURs,organics_2017_B50, by = c("permitsite" = "permtst"))
# KernAg_PUR_join_KernAgmismatch = anti_join(organics_2017_B50,uniquePURs,by = c("permtst" = "permitsite"))
```

#### 5. Determine the number of crops being grown on multi-crop fields (s_status == "M") and add information to the KernAg_CDFA_pesticideUse dataframe shapefile.
```{r deal_with_Mfields}

for(i in years){
  
  tmp_orgs_df = eval(as.name(paste0("organics_pest_",i)))
      
  # Turn the 2017 kernAg_CDFA_pest shapefile into a simple features (spatial) data.frame
      M_status_df = st_as_sf(tmp_orgs_df) %>% 
        # Turn into basic data.frame to remove spatial references
        as.data.frame() %>% 
        # Select columns relevant to dealing with M fields
        dplyr::select(permtst,s_stats)
  
      # Create a new column of permitsites with the last character trimmed from each 
      # 'permitsite' string that correspond to a field with an "M" in the "S_STATUS" column.

      # For rows with "M" in column "S_STATUS"
      M_status_df$permtst_trim1 = ifelse(M_status_df$s_stats == "M", 
          
        # Trim the last character off the 'permitsite' string
        strtrim(M_status_df$permtst,width=nchar(M_status_df$permtst)-1),
    
        # Leave other rows alone
        M_status_df$permtst)
    
      
      # Create another new column from the original "permitsite" field with only the last character 
      # from the string. This is used to double check the seperation of characters in the step above. If concatenated,
      # '_trim1' + '_trim2' should be identical to the original 'permitsite' string.  
      
      # If the value in 'S_STATUS' == M
      M_status_df$permtst_trim2 = ifelse(M_status_df$s_stats == "M",
                                     
           # Grab the last character in the 'permitsite' string
           substr(x = M_status_df$permtst,
           start = nchar(M_status_df$permtst),
           stop = nchar(M_status_df$permtst)), 
        
           # Otherwise make equal to NA
           NA)

      
      # Create a new dataframe that has each unique 'permitsite' string in the first column
      # and the number of times it is repeated in the second column. Multi-crop fields (S_STATUS == M) 
      # are consistently distinguised from one another by a unique character at the end (right side) 
      # of an otherwise identical 'permitsite' string. With the last character trimmed off of those strings, 
      # we can determine the number of crops in the multi-crop fields based on the number of duplicate
      # permitsites in the 'permitsite_trim1' column.
      prmtst_duplicates = as.data.frame(table(M_status_df$permtst_trim1))
      
      
      # Rename columns from generic names given by table() function
      colnames(prmtst_duplicates) = c('permitsite','n')
      
      # Merge multicrop_df data.frame (with permitsite_trim columns) and prmtst_dups data.frame. This merge 
      # allows us to see how many crops are associated with each permitsite i.e. how many 
      # crops are in each individual field. 
      M_status_df_final = merge(M_status_df, 
                                 prmtst_duplicates, 
                                 by.x="permtst_trim1", 
                                 by.y="permitsite", 
                                 type = "right") %>% 
        dplyr::select(permtst,n)
      
      # Rename columns for merge and later use
      colnames(M_status_df_final) = c("permtst","N_crops_prmtst")
      
      # Merge the final multicrop_df dataframe into the tmp_orgs_df_final simple features data.frame
      orgs_df_final = merge(tmp_orgs_df, M_status_df_final, by = 'permtst')
      
      # Remove extra dataframes that could accidentally carry into other years
      remove(M_status_df_final,prmtst_duplicates,M_status_df,tmp_orgs_df)
      
      # Convert the acres column to numeric
      orgs_df_final$acres = as.numeric(as.character(orgs_df_final$acres))
      
      # create a 'hectares' column using the 'acres' column
      orgs_df_final$hectares = orgs_df_final$acres*0.405/orgs_df_final$N_crops_prmtst
      
      # Create a kilograms of active ingredients per hectare column
      # orgs_df_final$kgAIperhec = orgs_df_final$KgPestAI/orgs_df_final$hectares
      # orgs_df_final$kgPrdPerHe = orgs_df_final$KgPestPrd/orgs_df_final$hectares
      
      # Remove the "permitno" and "location" columns
      # orgs_df_final = orgs_df_final %>% 
      #   select(-c("permitno","location"))
      
      # Save in global environment
      assign(paste0("organics_df_final_",i), orgs_df_final)
      
        # Write the shapefile in to the output directory
        writeOGR(as(orgs_df_final,"Spatial"),
                 paste0("../R_output/spatial/final_organics_data/",i),
                 paste0("all_organics_pest_",i),
                 driver = "ESRI Shapefile",
                 overwrite_layer = TRUE)
      
}

```




